<?php

namespace Tests\Feature\Controller\Product;

use App\Models\Product;
use Illuminate\Foundation\Testing\DatabaseTransactions;
use Illuminate\Support\Facades\Cache;
use Symfony\Component\HttpFoundation\Response;
use Tests\TestCase;
use Tests\TestData\TestUser;

class GetTest extends TestCase
{
    use DatabaseTransactions;

    private const CONTROLLER_ROUTE = '/api/product';
    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        TestUser::createAdminAuthorizedUser();
    }

    public function testGetProductSuccess(): void
    {
        $expectedProduct = $this->createProduct(false);

        $response = $this->getJson(
            self::CONTROLLER_ROUTE . '/' . $expectedProduct['id'],
            ['authorization' => 'Bearer ' . auth()->getToken()]
        );

        $response->assertOk();
        $response->assertJson([
            'title' => $expectedProduct['title'],
            'description' => $expectedProduct['description'],
            'type' => $expectedProduct['type'],
            'price' => $expectedProduct['price'],
        ]);
    }

    public function testGetProductFromCacheSuccess(): void
    {
        $expectedProduct = $this->createProduct(true);

        $response = $this->getJson(
            self::CONTROLLER_ROUTE . '/' . $expectedProduct['id'],
            ['authorization' => 'Bearer ' . auth()->getToken()]
        );

        $response->assertOk();
        $response->assertJson([
            'title' => $expectedProduct['title'],
            'description' => $expectedProduct['description'],
            'type' => $expectedProduct['type'],
            'price' => $expectedProduct['price'],
        ]);
    }

    public function testGetNonExistentProductShouldFail(): void
    {
        $response = $this->getJson(
            self::CONTROLLER_ROUTE . '/' . rand(1000, 2000),
            ['authorization' => 'Bearer ' . auth()->getToken()]
        );

        $response->assertStatus(Response::HTTP_NOT_FOUND);
        $decodedResponse = $response->decodeResponseJson();

        static::assertArrayHasKey('message', $decodedResponse);
        static::assertSame('Resource is not exist', $decodedResponse['message']);
    }

    public function testGetProductWithInvalidTokenShouldFail(): void
    {
        $invalidToken = 'eyJhbGciOiJIUzI1NiJ9.eyJpZCI6IjEifQ.ZAU547bnCcGrvSZiaDeYpbQg6rUopOe3HMJ01l2a2NQ';
        auth()->setToken($invalidToken);

        $this->createProduct(true);

        $response = $this->getJson(
            self::CONTROLLER_ROUTE . '/' . rand(1000, 2000),
            ['authorization' => 'Bearer ' . auth()->getToken()]
        );

        $response->assertStatus(Response::HTTP_UNAUTHORIZED);
        $decodedResponse = $response->decodeResponseJson();

        static::assertArrayHasKey('message', $decodedResponse);
        static::assertSame('Token Signature could not be verified.', $decodedResponse['message']);
    }

    private function createProduct(bool $withCache): array
    {
        $product = Product::factory()->createOne();
        $expectedProduct = $product->toArray();

        if ($withCache) {
            Cache::add('product:' . $expectedProduct['id'], serialize($expectedProduct));
            $product->delete();
        }

        return $expectedProduct;
    }
}
