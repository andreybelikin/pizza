<?php

namespace Tests\Feature\Controller\Product;

use App\Models\Product;
use Illuminate\Foundation\Testing\DatabaseTransactions;
use Illuminate\Testing\TestResponse;
use PHPUnit\Framework\Attributes\DataProvider;
use Symfony\Component\HttpFoundation\Response;
use Tests\TestCase;
use Tests\TestData\TestUser;
use Closure;

class IndexTest extends TestCase
{
    use DatabaseTransactions;

    private const CONTROLLER_ROUTE = '/api/product';
    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        TestUser::createAdminAuthorizedUser();
    }

    #[DataProvider('getProductsSuccessProvider')]
    public function testGetProductsSuccess(array $filters, array $productsValues, Closure $assertions): void
    {
        $expectedProducts = $this->createProducts($productsValues);
        $filterParameters = $this->addFilters($filters);

        $response = $this->getJson(
            self::CONTROLLER_ROUTE . $filterParameters,
            ['authorization' => 'Bearer ' . auth()->getToken()]
        );

        $assertions($expectedProducts, $response);
    }

    public static function getProductsSuccessProvider(): array
    {
        return [
            'getProductsShouldSuccess' => [
                'filters' => [],
                'productsValues' => [],
                'assertions' => function (array $expectedProducts, TestResponse $response) {
                    $response->assertStatus(Response::HTTP_OK);
                    $decodedResponse = $response->decodeResponseJson();

                    static::assertArrayHasKey('data', $decodedResponse);
                    $products = $decodedResponse['data'];
                    static::assertCount(3, $products);
                },
            ],
            'getFilteredProductsShouldSuccess' => [
                'filters' => [
                    'minPrice' => '3000',
                ],
                'productsValues' => [
                    ['price' => '4000'],
                    ['price' => '7000'],
                    ['price' => '1000'],
                ],
                'assertions' => function (array $expectedProducts, TestResponse $response) {
                    $response->assertStatus(Response::HTTP_OK);
                    $decodedResponse = $response->decodeResponseJson();

                    static::assertArrayHasKey('data', $decodedResponse);

                    $filteredProducts = $decodedResponse['data'];
                    static::assertCount(2, $filteredProducts);

                    foreach ($filteredProducts as $product) {
                        static::assertTrue(in_array($product['price'], ['4000', '7000']));
                    }
                },
            ]
        ];
    }

    public function testGetProductsWithNotValidFiltersFailed(): void
    {
        $this->createProducts([]);
        $filters = $this->addFilters(['type' => 'fish']);

        $response = $this->getJson(
            self::CONTROLLER_ROUTE . $filters,
            ['authorization' => 'Bearer ' . auth()->getToken()]
        );

        $response->assertStatus(Response::HTTP_BAD_REQUEST);
        $decodedResponse = $response->decodeResponseJson();

        static::assertArrayHasKey('message', $decodedResponse);
        static::assertSame('The given data failed to pass validation', $decodedResponse['message']);
    }

    public function testGetProductsWithInvalidTokenShouldFail(): void
    {
        $invalidToken = 'eyJhbGciOiJIUzI1NiJ9.eyJpZCI6IjEifQ.ZAU547bnCcGrvSZiaDeYpbQg6rUopOe3HMJ01l2a2NQ';
        auth()->setToken($invalidToken);

        $this->createProducts([]);

        $response = $this->getJson(
            self::CONTROLLER_ROUTE . '/' . rand(1000, 2000),
            ['authorization' => 'Bearer ' . auth()->getToken()]
        );

        $response->assertStatus(Response::HTTP_UNAUTHORIZED);
        $decodedResponse = $response->decodeResponseJson();

        static::assertArrayHasKey('message', $decodedResponse);
        static::assertSame('Token Signature could not be verified.', $decodedResponse['message']);
    }

    private function createProducts(array $ProductsValues): array
    {
        if (empty($ProductsValues)) {
            $products = Product::factory()->count(3)->create()->toArray();
        } else {
            $products = array_map(
                fn ($productValues) => Product::factory()->create($productValues)->toArray(),
                $ProductsValues)
            ;
        }

        return $products;
    }

    private function addFilters(array $filters): string
    {
        if (empty($filters)) {
            return '';
        }

        $filtersParams = '';

        foreach ($filters as $filterName => $filterValue) {
            $filtersParams .= sprintf('?%s=%s', $filterName, $filterValue);

            if (next($filters)) {
                $filtersParams .= sprintf('&%s=%s', $filterName, $filterValue);
            }
        }

        return $filtersParams;
    }
}
